// CNN-based digit recognition, Enes Altun, 2025 MIT License
// I trained my own version, by following the insights from kishimisu, 2023: https://www.shadertoy.com/view/msVXWD 

struct TimeUniform {
    time: f32,
    delta: f32,
    frame: u32,
    _padding: u32,
};
@group(0) @binding(0) var<uniform> time_data: TimeUniform;

struct CNNParams {
    canvas_size: f32,       
    brush_size: f32,        
    input_resolution: f32,  
    clear_canvas: i32,      
    show_debug: i32,        
    prediction_threshold: f32, 
    canvas_offset_x: f32,   
    canvas_offset_y: f32,
    feature_maps_1: f32,    
    feature_maps_2: f32,    
    num_classes: f32,       
    normalization_mean: f32,
    normalization_std: f32,
    show_frequencies: i32,
    conv1_pool_size: f32,
    conv2_pool_size: f32,
    _padding1: f32,
    _padding2: f32,
    _padding3: f32,
    _padding4: f32,
    _padding5: f32,
    _padding6: f32,
}
// Group 1: Primary Pass I/O & Parameters
@group(1) @binding(0) var output: texture_storage_2d<rgba16float, write>;
@group(1) @binding(1) var<uniform> params: CNNParams;

// Group 2: Engine Resources (Mouse & Fonts)
// note that, WebGPU only supports a maximum of 4 groups (0-3). But you can use more bindings :)
@group(2) @binding(0) var<uniform> mouse: MouseUniform;
@group(2) @binding(1) var<uniform> font_texture_uniform: FontUniforms;
@group(2) @binding(2) var t_font_texture_atlas: texture_2d<f32>;

@group(3) @binding(0) var<storage, read_write> canvas_data: array<f32>;      
@group(3) @binding(1) var<storage, read_write> conv1_data: array<f32>;       
@group(3) @binding(2) var<storage, read_write> conv2_data: array<f32>;       
@group(3) @binding(3) var<storage, read_write> fc_data: array<f32>;

// Font utilities
const CHAR_0: u32 = 48u;  // ASCII '0'

// render single character
fn ch(pp: vec2<f32>, pos: vec2<f32>, code: u32, size: f32) -> f32 {
    let char_size_pixels = vec2<f32>(size, size);
    let relative_pos = pp - pos;

    // Check bounds
    if (relative_pos.x < 0.0 || relative_pos.x >= char_size_pixels.x ||
        relative_pos.y < 0.0 || relative_pos.y >= char_size_pixels.y) {
        return 0.0;
    }

    // Calculate UV coordinates within the character cell
    let local_uv = relative_pos / char_size_pixels;

    // calc char pos in atlas grid (16x16)
    let grid_x = code % 16u;
    let grid_y = code / 16u;

    // padding to avoid cell bleeding
    let padding = 0.05;
    let padded_uv = local_uv * (1.0 - 2.0 * padding) + vec2<f32>(padding);

    // atlas UV coords
    let cell_size_uv = vec2<f32>(1.0 / 16.0, 1.0 / 16.0);
    let cell_offset = vec2<f32>(f32(grid_x), f32(grid_y)) * cell_size_uv;
    let final_uv = cell_offset + padded_uv * cell_size_uv;

    // sample font atlas with textureLoad
    let atlas_coord = vec2<i32>(
        i32(final_uv.x * font_texture_uniform.atlas_size.x),
        i32(final_uv.y * font_texture_uniform.atlas_size.y)
    );
    let sample = textureLoad(t_font_texture_atlas, atlas_coord, 0);

    // red channel font data + anti-alias
    let font_alpha = sample.r * 0.8;
    return smoothstep(0.1, 0.9, font_alpha);
}

struct FontUniforms {
    atlas_size: vec2<f32>,
    char_size: vec2<f32>,
    screen_size: vec2<f32>,
    grid_size: vec2<f32>,
};

struct MouseUniform {
    position: vec2<f32>,
    click_position: vec2<f32>,
    wheel: vec2<f32>,
    buttons: vec2<u32>,
};          

const INPUT_SIZE: u32 = 28u;
const CONV1_SIZE: u32 = 12u;  
const CONV2_SIZE: u32 = 4u;   
const FEATURE_MAPS_1: u32 = 8u;
const FEATURE_MAPS_2: u32 = 5u;
const NUM_CLASSES: u32 = 10u;

fn get_conv1_weight(feature_map: i32, kernel_idx: i32) -> f32 {
    if (feature_map == 0) {
        let weights = array<f32, 25>(
            0.059118, 0.212598, 0.133028, -0.090579, 0.014379,
            -0.293498, 0.107810, 0.100351, 0.016542, -0.059824,
            -0.094256, 0.105705, 0.116418, -0.035735, -0.208054,
            0.124250, 0.171374, 0.038988, 0.021277, -0.112267,
            0.628066, 0.004966, 0.105534, 0.026457, -0.317035
        );
        return weights[kernel_idx];
    } else if (feature_map == 1) {
        let weights = array<f32, 25>(
            0.090732, 0.065419, 0.106401, -0.084021, -0.647136,
            0.108799, 0.089764, -0.121682, -0.533880, -0.178817,
            0.027257, -0.318298, -0.507131, -0.310316, 0.125244,
            -0.301398, -0.452392, -0.131039, 0.022200, 0.097774,
            -0.733253, -0.024898, 0.015335, 0.047249, 0.131028
        );
        return weights[kernel_idx];
    } else if (feature_map == 2) {
        let weights = array<f32, 25>(
            0.130385, -0.207631, -0.092937, -0.178564, 0.194926,
            0.355522, -0.168801, -0.117155, -0.329194, 0.230071,
            0.311475, -0.076092, -0.258192, -0.207036, 0.353810,
            0.131146, -0.129740, -0.385045, -0.002601, 0.211411,
            -0.100129, -0.049414, 0.092165, 0.263012, -0.095754
        );
        return weights[kernel_idx];
    } else if (feature_map == 3) {
        let weights = array<f32, 25>(
            0.047424, 0.363922, 0.161570, 0.038864, 0.297599,
            -0.506781, 0.031212, 0.212022, 0.216973, 0.033948,
            -0.550634, -0.463300, -0.208913, -0.078454, -0.302477,
            -0.191406, -0.487218, -0.622391, -0.568604, -0.479992,
            0.186637, 0.107024, 0.098447, 0.144072, -0.050881
        );
        return weights[kernel_idx];
    } else if (feature_map == 4) {
        let weights = array<f32, 25>(
            -0.085029, -0.230513, -0.215414, -0.032263, 0.200012,
            -0.149198, -0.304278, 0.021139, 0.085227, 0.187919,
            -0.484779, -0.107232, -0.010055, 0.118823, 0.195574,
            -0.339765, -0.000136, -0.012461, 0.088286, 0.121931,
            -0.209613, -0.095666, -0.058312, 0.082218, 0.274804
        );
        return weights[kernel_idx];
    } else if (feature_map == 5) {
        let weights = array<f32, 25>(
            0.011292, -0.184161, -0.323151, -0.329524, -0.646986,
            0.093659, 0.237659, 0.173439, -0.032493, -0.599618,
            -0.068061, 0.144960, 0.265278, 0.012735, -0.345550,
            -0.057056, -0.130387, 0.209003, 0.068700, -0.149392,
            0.008365, 0.035129, 0.247323, 0.301090, 0.278756
        );
        return weights[kernel_idx];
    } else if (feature_map == 6) {
        let weights = array<f32, 25>(
            -0.286733, -0.370776, -0.498713, -0.375358, -0.314717,
            -0.004516, -0.094489, -0.124230, -0.113929, 0.047390,
            -0.200253, -0.013750, -0.017322, 0.142239, 0.297712,
            -0.188307, -0.054486, 0.259562, 0.289841, 0.124242,
            -0.050348, 0.113242, 0.152553, 0.029973, 0.096731
        );
        return weights[kernel_idx];
    } else if (feature_map == 7) {
        let weights = array<f32, 25>(
            0.584507, 0.577468, 0.135214, -0.041525, -0.101412,
            -0.097004, -0.314614, 0.037897, -0.010884, 0.010803,
            -0.720320, -0.422073, 0.106106, -0.053629, 0.083413,
            -0.093764, -0.023022, 0.020779, 0.050639, 0.053201,
            0.210956, 0.145139, -0.079061, -0.053828, -0.060777
        );
        return weights[kernel_idx];
    }
    return 0.0;
}

fn get_conv1_bias(feature_map: i32) -> f32 {
    let biases = array<f32, 8>(-0.995146, -0.583638, 0.020400, -0.799418, -0.756995, -0.566878, -0.495447, 0.050287);
    return biases[feature_map];
}

fn get_conv2_weight(output_fmap: i32, input_fmap: i32, kernel_idx: i32) -> f32 {
    if (output_fmap == 0) {
        if (input_fmap == 0) {
            let weights = array<f32, 25>(
                -0.440920, -0.305167, -0.386697, -0.093114, -0.105637,
                -0.226942, -0.217724, -0.218476, -0.275672, -0.036137,
                0.085342, 0.026542, 0.084779, 0.021381, 0.134637,
                0.160113, -0.047606, 0.099483, -0.007895, 0.050458,
                0.304914, 0.151331, 0.295998, 0.209482, 0.090494
            );
            return weights[kernel_idx];
        } else if (input_fmap == 1) {
            let weights = array<f32, 25>(
                -0.019222, -0.086378, 0.269720, 0.095286, 0.286895,
                0.071631, 0.074230, 0.283192, -0.000011, 0.234435,
                0.156321, -0.040638, -0.188319, 0.016656, 0.285061,
                -0.169859, 0.016525, 0.175798, 0.254453, 0.202435,
                -0.692843, -0.518418, -0.203386, -0.237364, -0.363988
            );
            return weights[kernel_idx];
        } else if (input_fmap == 2) {
            let weights = array<f32, 25>(
                -0.171705, 0.320031, 0.113270, 0.072826, 0.062855,
                0.294732, 0.306850, 0.239197, 0.364810, 0.236743,
                0.186280, 0.393276, 0.163195, 0.296794, 0.149227,
                0.189778, 0.291288, 0.115883, 0.289310, 0.254431,
                0.274914, 0.123054, 0.010794, 0.022348, 0.225360
            );
            return weights[kernel_idx];
        } else if (input_fmap == 3) {
            let weights = array<f32, 25>(
                0.253940, 0.119137, -0.046428, -0.139875, -1.034097,
                0.348993, 0.144549, 0.054189, -0.460819, -1.101262,
                0.232694, -0.118662, -0.067566, -0.836966, -1.056124,
                -0.272415, -0.083702, -0.279675, -0.627525, -0.351323,
                -0.213945, -0.399971, -0.087757, 0.013577, 0.130731
            );
            return weights[kernel_idx];
        } else if (input_fmap == 4) {
            let weights = array<f32, 25>(
                -0.721656, 0.145863, 0.263578, 0.070307, -0.073231,
                0.259390, -0.092847, 0.099211, 0.290092, 0.089562,
                0.305273, -0.068595, -0.074493, -0.062266, -0.123206,
                -0.058300, -0.140627, 0.177652, 0.271665, 0.094064,
                -0.241491, 0.081361, 0.307453, 0.058221, -0.043077
            );
            return weights[kernel_idx];
        } else if (input_fmap == 5) {
            let weights = array<f32, 25>(
                0.699612, -0.105945, -0.071931, 0.224148, 0.191767,
                0.134611, -0.114294, -0.120286, 0.122610, -0.168122,
                0.080286, -0.002624, -0.129236, -0.103284, -0.038099,
                0.011747, -0.003257, -0.157498, -0.196834, 0.139313,
                0.078519, 0.105239, -0.102472, -0.040691, 0.238806
            );
            return weights[kernel_idx];
        } else if (input_fmap == 6) {
            let weights = array<f32, 25>(
                0.226996, -0.830254, -0.319759, -0.144071, -0.221284,
                0.534730, -0.309743, -0.012132, 0.013405, -0.011811,
                0.158130, 0.081425, 0.006953, 0.107102, 0.010553,
                0.341117, 0.017140, -0.016251, -0.025375, 0.089398,
                0.282354, 0.104629, 0.060886, -0.039699, 0.365968
            );
            return weights[kernel_idx];
        } else if (input_fmap == 7) {
            let weights = array<f32, 25>(
                -0.154717, -0.236233, -0.112206, -0.017676, -0.642533,
                -0.499141, -0.299352, -0.264891, -0.242732, -0.386353,
                -0.268501, -0.155866, -0.014217, -0.091878, -0.290944,
                0.015766, -0.055867, -0.078283, -0.009615, -0.136057,
                0.083432, -0.034049, -0.087414, -0.024692, -0.069139
            );
            return weights[kernel_idx];
        }
    } else if (output_fmap == 1) {
        if (input_fmap == 0) {
            let weights = array<f32, 25>(
                -0.602464, -0.270322, -0.055167, -0.147378, -0.316224,
                0.016757, 0.292407, -0.124001, -0.401818, -0.108311,
                0.498141, -0.180163, -0.326911, -0.089652, 0.561297,
                0.035126, -0.057385, -0.253210, 0.530580, 0.496698,
                -0.311058, -0.412749, -0.228873, -0.047509, -0.154245
            );
            return weights[kernel_idx];
        } else if (input_fmap == 1) {
            let weights = array<f32, 25>(
                -0.312256, -0.277890, -0.011397, -0.180167, 0.023855,
                -0.291844, 0.304113, 0.297572, -0.227892, -0.561217,
                0.117959, 0.012221, -0.325754, -0.435556, 0.116363,
                -0.041911, -1.181004, -0.779547, -0.375083, 0.181658,
                -0.497692, -1.743128, -0.682871, -0.369984, 0.443826
            );
            return weights[kernel_idx];
        } else if (input_fmap == 2) {
            let weights = array<f32, 25>(
                0.146465, 0.524455, 0.252042, 0.247059, 0.172239,
                0.079564, 0.405657, 0.181439, 0.207727, 0.204652,
                -0.015534, 0.180269, 0.211342, 0.345454, 0.373103,
                0.083042, 0.264457, 0.173432, 0.103368, 0.357305,
                -0.064516, -0.213763, -0.573244, -0.101265, -0.065098
            );
            return weights[kernel_idx];
        } else if (input_fmap == 3) {
            let weights = array<f32, 25>(
                -0.299791, -0.040413, -0.666464, 0.055649, 0.007844,
                -0.612418, -0.840131, -0.206042, 0.024377, 0.000463,
                -1.216439, -0.822456, -0.295739, -0.203300, -0.768272,
                -0.375283, -0.020260, -0.222263, -0.251606, -0.298905,
                -0.290258, 0.013554, -0.183804, -0.303069, -0.215955
            );
            return weights[kernel_idx];
        } else if (input_fmap == 4) {
            let weights = array<f32, 25>(
                0.131080, -0.211119, -0.194156, -0.106298, -0.058308,
                0.130105, -0.286607, -0.306242, -0.008129, 0.138911,
                0.134058, -0.266391, -0.054576, -0.117873, 0.072421,
                0.361107, 0.161658, -0.202935, -0.292615, 0.016806,
                0.163151, -0.804368, -0.841711, -0.492362, -1.313826
            );
            return weights[kernel_idx];
        } else if (input_fmap == 5) {
            let weights = array<f32, 25>(
                0.532508, -0.116481, -0.184941, -0.095533, 0.293859,
                0.141367, -0.416096, -0.289453, -0.021452, 0.321215,
                -0.511162, -0.494385, -0.046304, 0.078316, 0.204250,
                -0.316711, 0.061145, 0.248272, 0.176797, 0.033939,
                1.141642, 0.468035, 0.345939, 0.123256, -0.280909
            );
            return weights[kernel_idx];
        } else if (input_fmap == 6) {
            let weights = array<f32, 25>(
                -0.199065, 0.283804, 0.096952, 0.136749, 0.031043,
                -0.137320, 0.399116, 0.240304, 0.218069, -0.013263,
                0.001478, -0.027426, -0.095828, -0.091509, 0.078285,
                -0.224602, -0.401464, -0.150715, 0.091846, 0.696177,
                -1.003770, -1.138438, 0.211916, 0.389586, 0.455906
            );
            return weights[kernel_idx];
        } else if (input_fmap == 7) {
            let weights = array<f32, 25>(
                0.034463, 0.027030, 0.298367, 0.093808, 0.098291,
                0.082968, -0.078708, 0.224717, 0.404312, 0.578102,
                -0.361233, 0.297210, 0.152150, 0.665929, 0.437151,
                -0.512798, -0.245046, 0.508775, 0.309647, 0.192541,
                -0.140532, -0.043037, -0.020910, 0.304050, 0.360302
            );
            return weights[kernel_idx];
        }
    } else if (output_fmap == 2) {
        if (input_fmap == 0) {
            let weights = array<f32, 25>(
                0.243033, 0.345421, 0.173696, 0.179660, 0.337556,
                0.022883, -0.081055, -0.035149, -0.083057, -0.234987,
                0.088092, -0.075703, -0.121228, -0.079098, 0.114919,
                0.342707, 0.210423, -0.099130, -0.115513, 0.139452,
                0.098298, 0.219795, 0.304262, -0.011747, 0.028923
            );
            return weights[kernel_idx];
        } else if (input_fmap == 1) {
            let weights = array<f32, 25>(
                0.043101, 0.175730, 0.216059, 0.001717, 0.002142,
                -0.069345, 0.119760, -0.091295, 0.279311, -0.035763,
                -0.066309, -0.067509, -0.181624, 0.188899, -0.080585,
                -0.137770, 0.069486, 0.072013, 0.415739, 0.437041,
                0.024024, 0.108675, 0.061731, 0.131860, 0.388306
            );
            return weights[kernel_idx];
        } else if (input_fmap == 2) {
            let weights = array<f32, 25>(
                0.016289, -0.000797, -0.008743, 0.077486, 0.146315,
                0.045406, -0.165941, -0.087231, 0.130451, -0.039750,
                0.175352, 0.188814, 0.079625, 0.073619, 0.084222,
                0.142870, 0.191985, 0.168857, 0.070348, 0.450652,
                0.006195, -0.032708, 0.026438, -0.080683, -0.355471
            );
            return weights[kernel_idx];
        } else if (input_fmap == 3) {
            let weights = array<f32, 25>(
                -0.619559, -0.018747, 0.045381, 0.126087, -0.154164,
                -0.365295, -0.226217, -0.149919, 0.134864, -0.194506,
                -0.345580, -0.360954, -0.441363, 0.165439, -0.140239,
                -0.439139, -0.357070, -0.558956, -0.217523, -0.333751,
                -0.189475, -0.209346, -0.874387, -0.463252, -0.234479
            );
            return weights[kernel_idx];
        } else if (input_fmap == 4) {
            let weights = array<f32, 25>(
                0.494965, 0.292714, 0.086406, 0.006011, 0.176184,
                0.130608, 0.133725, 0.035144, -0.395029, 0.012266,
                -0.004941, 0.172197, 0.252414, 0.083296, 0.150801,
                -0.159792, 0.111279, 0.401483, -0.034346, 0.157452,
                -0.064002, 0.012588, -0.032622, -0.358437, -0.744726
            );
            return weights[kernel_idx];
        } else if (input_fmap == 5) {
            let weights = array<f32, 25>(
                0.267075, -0.012623, 0.102294, -0.193862, -0.320633,
                0.143731, 0.204034, 0.188879, -0.004063, 0.148170,
                0.122507, 0.295760, -0.054125, -0.165774, -0.094614,
                -0.070533, 0.018508, 0.018279, -0.201893, -0.398960,
                0.055041, 0.005529, 0.121662, 0.244309, -0.157051
            );
            return weights[kernel_idx];
        } else if (input_fmap == 6) {
            let weights = array<f32, 25>(
                -0.173864, -0.033868, -0.061621, -0.369035, -0.870607,
                0.199040, -0.122495, -0.215640, -0.681284, -0.203962,
                0.051391, 0.083884, -0.277810, -0.538265, -0.166713,
                -0.088678, 0.080126, 0.102288, 0.100051, 0.097836,
                0.090018, -0.218692, -0.180973, -0.114929, 0.203860
            );
            return weights[kernel_idx];
        } else if (input_fmap == 7) {
            let weights = array<f32, 25>(
                0.080944, -0.142618, -0.069132, -0.320075, 0.051906,
                0.232713, -0.048123, -0.124808, -0.135674, -0.010941,
                0.210800, 0.084226, -0.143164, -0.259473, -0.065854,
                0.201626, 0.124888, -0.128232, -0.222522, -0.187152,
                0.226320, 0.016428, -0.007410, -0.132940, -0.173187
            );
            return weights[kernel_idx];
        }
    } else if (output_fmap == 3) {
        if (input_fmap == 0) {
            let weights = array<f32, 25>(
                -0.331234, -0.069826, -0.298373, -0.418950, -0.130601,
                -0.038065, -0.107590, -0.329129, -0.239962, 0.097355,
                0.062893, -0.292562, -0.304276, -0.031381, 0.444057,
                -0.244186, -0.245650, -0.068485, 0.057721, 0.349107,
                -0.199887, -0.108850, 0.048608, -0.042634, 0.292001
            );
            return weights[kernel_idx];
        } else if (input_fmap == 1) {
            let weights = array<f32, 25>(
                0.109715, -0.261428, -0.600505, -0.875687, -0.818769,
                0.319666, -0.147813, -0.381825, -0.781691, -0.834011,
                0.429282, 0.110572, 0.077803, -0.581574, -0.536827,
                0.064509, -0.077075, -0.040817, -0.029614, -0.438771,
                -0.151469, -0.146505, -0.136961, 0.020541, -0.204943
            );
            return weights[kernel_idx];
        } else if (input_fmap == 2) {
            let weights = array<f32, 25>(
                -0.353253, 0.027455, -0.036780, -0.046895, -0.021547,
                -0.203297, 0.211864, -0.009219, 0.033770, 0.096888,
                0.114624, 0.255732, 0.192029, 0.170986, 0.072859,
                0.334925, 0.316676, 0.147584, 0.075729, 0.136888,
                0.089157, 0.307063, 0.210907, 0.315678, 0.412735
            );
            return weights[kernel_idx];
        } else if (input_fmap == 3) {
            let weights = array<f32, 25>(
                0.165340, 0.142610, 0.143173, 0.241119, -0.633291,
                0.372892, 0.208692, 0.046776, 0.027553, -0.699828,
                0.184869, 0.109916, -0.199313, -0.364832, -0.813437,
                0.066790, -0.042537, -0.219229, -0.311831, -0.512172,
                0.036208, -0.136164, -0.133502, -0.183997, -0.385964
            );
            return weights[kernel_idx];
        } else if (input_fmap == 4) {
            let weights = array<f32, 25>(
                0.388904, -0.091864, -0.354799, -0.490165, -0.349984,
                -0.192489, -0.319717, -0.138990, -0.128852, 0.165792,
                -0.026534, -0.308277, -0.014603, -0.042459, 0.494849,
                0.127808, -0.287995, -0.140294, -0.107099, 0.306081,
                0.011513, -0.063976, -0.039632, -0.030066, 0.509623
            );
            return weights[kernel_idx];
        } else if (input_fmap == 5) {
            let weights = array<f32, 25>(
                0.360853, 0.209328, 0.328841, 0.203737, 0.400659,
                0.268666, 0.023033, 0.143966, 0.012099, -0.048329,
                -0.296759, -0.051519, 0.014515, -0.144279, -0.167228,
                -0.069799, -0.338719, -0.094658, -0.222938, -0.163464,
                -0.010884, 0.016962, 0.003131, -0.323057, -0.111836
            );
            return weights[kernel_idx];
        } else if (input_fmap == 6) {
            let weights = array<f32, 25>(
                0.383404, -0.037909, -0.181112, -0.249615, -0.247953,
                0.444496, 0.334008, 0.008163, -0.152695, -0.350647,
                0.466792, 0.383746, 0.068954, 0.109296, -0.178616,
                0.141708, 0.336621, 0.220481, 0.273007, -0.202447,
                -0.027413, 0.109541, 0.255679, 0.418807, -0.107098
            );
            return weights[kernel_idx];
        } else if (input_fmap == 7) {
            let weights = array<f32, 25>(
                -0.412988, -0.036014, 0.022593, 0.118563, 0.119420,
                -0.279206, 0.146118, 0.402327, 0.200899, 0.041073,
                -0.112772, 0.157315, 0.209152, 0.250257, 0.187021,
                -0.031674, -0.080702, 0.195421, 0.131116, 0.147019,
                -0.145014, -0.010085, 0.124454, 0.116853, 0.165799
            );
            return weights[kernel_idx];
        }
    } else if (output_fmap == 4) {
        if (input_fmap == 0) {
            let weights = array<f32, 25>(
                -0.477404, -0.067036, 0.439892, 0.367303, 0.369069,
                -0.022664, 0.042587, 0.212378, 0.055972, -0.093254,
                -0.301879, -0.089497, 0.037198, 0.076495, -0.427392,
                -0.547883, -0.132255, -0.696607, -0.605294, -0.001701,
                -0.125266, 0.443379, 0.274799, -0.134405, -0.556577
            );
            return weights[kernel_idx];
        } else if (input_fmap == 1) {
            let weights = array<f32, 25>(
                -0.284529, -0.143155, -0.258662, 0.065377, -0.031407,
                -0.534858, 0.001464, -0.086043, 0.135867, 0.274168,
                -0.440651, -0.030269, 0.216717, 0.184452, 0.258092,
                0.065515, 0.184754, 0.346428, 0.558850, 0.364878,
                0.100558, 0.084334, -0.243033, -0.356647, -0.163924
            );
            return weights[kernel_idx];
        } else if (input_fmap == 2) {
            let weights = array<f32, 25>(
                0.037889, 0.235474, 0.290230, 0.311721, 0.185874,
                0.191789, -0.321137, -0.055315, -0.140873, -0.075383,
                -0.327705, -0.682166, -0.472463, -0.268112, -0.240359,
                -0.587919, -0.588064, -0.377422, -0.296871, -0.090682,
                -0.255734, -0.143778, 0.068308, -0.225708, -0.431324
            );
            return weights[kernel_idx];
        } else if (input_fmap == 3) {
            let weights = array<f32, 25>(
                -0.045186, -0.082867, -0.054078, 0.102551, -0.163784,
                0.135860, -0.076279, 0.041190, 0.006834, -0.056241,
                0.288208, 0.063270, -0.052403, 0.242720, -0.130487,
                0.467138, 0.294971, 0.399265, -0.200408, -0.060624,
                0.487152, -0.172803, 0.200344, 0.444449, 0.057820
            );
            return weights[kernel_idx];
        } else if (input_fmap == 4) {
            let weights = array<f32, 25>(
                0.046171, 0.376711, 0.457108, 0.277103, 0.035221,
                -0.585500, -0.044366, -0.157766, 0.158052, 0.105806,
                -0.765715, 0.170560, -0.143694, -0.002818, -0.136283,
                -0.322265, 0.308525, 0.450055, 0.134690, 0.032322,
                -0.102514, 0.171593, -0.077076, -0.336530, -0.420271
            );
            return weights[kernel_idx];
        } else if (input_fmap == 5) {
            let weights = array<f32, 25>(
                0.010328, 0.001460, -0.153807, -0.034855, -0.147428,
                0.285725, -0.090264, -0.479810, -0.404318, -0.400276,
                0.475835, 0.555178, -0.218474, -0.625011, -0.405162,
                -0.022585, 0.663873, 0.227576, -0.230673, -0.378163,
                -0.564438, 0.016621, 0.237209, 0.515972, 0.588577
            );
            return weights[kernel_idx];
        } else if (input_fmap == 6) {
            let weights = array<f32, 25>(
                0.105330, -0.074126, -0.021989, 0.090484, 0.090778,
                0.089042, -0.113645, -0.051757, 0.001980, 0.215407,
                0.191317, 0.371680, -0.249521, -0.468190, 0.472208,
                0.432208, 0.444493, 0.700976, 0.232956, 0.132317,
                0.379671, -0.123834, -0.185851, 0.055800, 0.770582
            );
            return weights[kernel_idx];
        } else if (input_fmap == 7) {
            let weights = array<f32, 25>(
                0.010429, -0.005792, -0.010797, 0.163197, -0.123874,
                -0.161378, 0.038045, -0.013360, 0.006958, -0.106368,
                -0.057850, -0.123145, -0.067227, 0.007692, -0.172799,
                -0.146381, -0.140483, -0.232477, 0.130497, 0.292331,
                0.047187, -0.015078, -0.191539, -0.061278, 0.017642
            );
            return weights[kernel_idx];
        }
    }
    return 0.0;
}

fn get_conv2_bias(feature_map: i32) -> f32 {
    let biases = array<f32, 5>(0.035646, 0.980448, 0.777028, 0.322329, -0.321281);
    return biases[feature_map];
}

fn get_fc_weight(class_idx: i32, input_idx: i32) -> f32 {
    if (class_idx == 0) {
        let weights = array<f32, 80>(
            0.144939, -0.022969, -0.068315, -0.045464, 0.019522, 0.000894, 0.037298, 0.066491, 0.001049, -0.044025,
            -0.010752, 0.024803, 0.052705, 0.146453, 0.146221, 0.275770, 0.091712, -0.058138, -0.057863, -0.113564,
            0.151347, 0.012548, 0.044228, -0.016024, 0.083453, -0.020938, 0.007271, -0.033532, 0.194055, 0.128059,
            0.192798, -0.001175, -0.153238, -0.157457, -0.135026, 0.034820, 0.254263, 0.113966, 0.042644, 0.013426,
            0.088235, 0.127979, 0.178539, 0.156284, 0.405063, 0.088157, 0.024046, -0.293551, -0.156947, 0.091217,
            -0.033083, 0.177798, -0.155832, 0.014659, -0.119612, 0.071445, -0.211656, 0.057923, -0.049633, 0.110484,
            -0.569734, -0.057469, -0.139796, -0.044398, -0.018407, -0.006130, 0.085207, 0.101348, -0.279335, -0.158008,
            0.005381, 0.155486, -0.275397, -0.024372, 0.126211, 0.246220, -0.106314, 0.122885, 0.273505, 0.276831
        );
        return weights[input_idx];
    } else if (class_idx == 1) {
        let weights = array<f32, 80>(
            -0.129904, 0.087061, 0.205505, 0.227064, -0.046303, 0.047721, 0.037196, 0.083276, 0.085067, 0.153174,
            0.113279, 0.016811, -0.001324, 0.115786, 0.213716, 0.091534, -0.649473, -0.454992, -0.255333, -0.198014,
            -0.596179, -0.342634, -0.260093, -0.190146, -0.495873, -0.270145, -0.274491, -0.096527, -0.386282, -0.287867,
            -0.336000, -0.071430, 0.046765, 0.410402, 0.234683, 0.321537, 0.065022, 0.226287, 0.040586, 0.085317,
            0.121128, 0.146596, 0.042166, 0.139151, 0.183086, 0.023777, -0.111326, -0.112069, -0.169956, -0.196357,
            -0.208496, -0.065039, -0.206600, -0.103566, -0.023320, -0.050180, -0.055910, -0.104884, -0.126850, -0.279428,
            -0.061199, -0.107343, -0.057109, -0.295479, 0.079782, 0.013628, -0.089510, -0.120582, 0.137742, 0.085764,
            0.079470, 0.070855, 0.085570, -0.017511, -0.024138, 0.010617, 0.065305, -0.120306, -0.110398, -0.008354
        );
        return weights[input_idx];
    } else if (class_idx == 2) {
        let weights = array<f32, 80>(
            -0.292376, -0.166897, -0.055549, -0.009682, 0.031935, -0.016869, 0.023576, 0.023161, 0.011646, -0.010951,
            0.036121, 0.061920, 0.262696, 0.151055, 0.208190, 0.291316, -0.373626, -0.152250, -0.150290, -0.112404,
            -0.078974, 0.005001, -0.021543, 0.014989, 0.038239, 0.023861, 0.000539, 0.000881, 0.142180, 0.101853,
            0.115618, 0.160879, -0.167365, 0.195642, 0.222557, 0.270460, -0.217955, 0.051404, 0.100495, -0.023664,
            -0.253015, -0.167983, -0.055065, -0.210482, -0.450246, -0.462997, -0.339643, -0.394741, 0.282535, 0.199042,
            0.205610, 0.283572, 0.026312, -0.016446, 0.028549, 0.002723, 0.205436, 0.050036, 0.074044, -0.096600,
            0.037369, -0.074426, -0.073176, -0.294321, 0.257862, 0.190457, 0.180805, 0.106854, 0.199841, 0.173030,
            0.112996, 0.051434, 0.219113, 0.049585, 0.011171, -0.056299, 0.128324, -0.149556, -0.089922, -0.178146
        );
        return weights[input_idx];
    } else if (class_idx == 3) {
        let weights = array<f32, 80>(
            -0.500330, -0.254729, -0.127307, -0.180128, -0.219950, -0.219969, -0.248036, -0.193880, -0.315463, -0.292831,
            -0.188714, -0.141945, -0.072089, -0.057888, -0.155579, -0.244873, -0.521794, -0.159480, -0.173660, 0.039001,
            -0.208462, -0.042689, -0.112778, -0.025308, -0.158237, 0.023417, 0.034594, 0.105684, -0.018045, -0.051790,
            -0.057404, -0.124037, -0.264346, 0.106560, 0.156361, 0.100803, -0.242010, 0.011252, 0.063626, 0.092844,
            -0.147361, -0.020064, -0.066555, -0.009649, -0.206834, 0.209453, 0.276628, 0.331523, 0.375792, 0.222161,
            0.245515, 0.254755, -0.066427, -0.091577, -0.032973, 0.013712, 0.164711, 0.090650, 0.051225, 0.101753,
            0.094909, 0.136888, 0.115829, 0.365293, 0.146319, 0.095202, 0.035455, -0.030914, 0.101603, 0.042881,
            -0.015690, -0.022526, 0.232869, 0.122901, 0.085406, 0.117433, 0.490539, 0.176471, 0.184816, 0.209402
        );
        return weights[input_idx];
    } else if (class_idx == 4) {
        let weights = array<f32, 80>(
            0.294697, 0.404236, 0.356165, 0.299895, 0.032690, 0.125139, 0.164254, 0.266688, 0.064380, 0.219578,
            0.210184, 0.282407, -0.214291, -0.225959, -0.135227, 0.025362, 0.263771, 0.172939, 0.165479, 0.060843,
            0.033777, -0.029340, -0.022950, -0.042574, 0.017208, 0.029826, -0.027140, -0.142666, -0.149357, -0.167932,
            -0.183298, -0.169942, 0.306028, 0.087972, -0.047152, -0.061951, 0.225744, 0.021983, -0.087771, -0.068707,
            0.171647, -0.088778, -0.163440, -0.176110, -0.162046, -0.165984, -0.210826, -0.252436, -0.274938, -0.296288,
            -0.266843, -0.344665, 0.085098, 0.146622, 0.097516, -0.028985, 0.096592, 0.027797, 0.009306, -0.087738,
            0.149639, 0.101548, 0.046285, -0.097596, -0.183286, -0.103974, -0.183471, -0.230181, 0.101608, 0.031371,
            -0.141256, -0.328371, -0.088918, -0.212944, -0.253681, -0.388161, -0.416298, -0.431019, -0.439039, -0.535295
        );
        return weights[input_idx];
    } else if (class_idx == 5) {
        let weights = array<f32, 80>(
            0.051021, 0.014558, -0.157677, -0.206517, -0.099574, -0.004667, -0.110120, -0.272613, -0.045895, -0.001378,
            -0.069450, 0.029139, -0.172001, -0.023270, -0.059014, -0.166391, 0.263537, 0.184963, 0.092568, 0.098056,
            -0.019981, 0.075103, 0.044928, 0.061189, -0.083977, -0.020838, 0.033533, 0.044590, 0.014595, 0.011688,
            0.064217, -0.078746, -0.236416, -0.375084, -0.277265, -0.520833, -0.166859, -0.256395, -0.088259, -0.132461,
            -0.054091, 0.057505, 0.090053, 0.073535, 0.078730, 0.350328, 0.360300, 0.296023, -0.235344, -0.226252,
            -0.261471, -0.538815, 0.059415, -0.035378, -0.034607, -0.281478, -0.097224, -0.033450, -0.033352, -0.043591,
            0.154635, 0.043485, 0.059922, 0.292069, -0.161003, -0.130759, -0.060524, -0.011668, 0.182934, 0.084328,
            0.051541, 0.086503, 0.200157, 0.178926, 0.169897, 0.306682, 0.451560, 0.299241, 0.313939, 0.403177
        );
        return weights[input_idx];
    } else if (class_idx == 6) {
        let weights = array<f32, 80>(
            0.321483, 0.087866, -0.007538, -0.097037, 0.062018, -0.040762, 0.055278, -0.055543, 0.065086, -0.054112,
            -0.007808, -0.095018, 0.194399, 0.100490, 0.100129, -0.035443, 0.327325, 0.102648, 0.104673, 0.052209,
            0.251340, 0.107241, 0.166806, 0.201463, 0.202869, 0.074884, 0.111609, 0.195190, 0.311242, 0.287047,
            0.285778, 0.365278, 0.382558, 0.064925, 0.032195, 0.019703, 0.062990, -0.094339, -0.041821, 0.027686,
            -0.032712, -0.083180, 0.001424, 0.088344, 0.371520, 0.020758, -0.024297, -0.019763, -0.555037, -0.573047,
            -0.468885, -0.513447, -0.197823, -0.186142, -0.104851, -0.150714, -0.331786, -0.176748, -0.123854, -0.091924,
            -0.347997, -0.199529, -0.197574, -0.146126, -0.483491, -0.350793, -0.199991, -0.057484, -0.383187, -0.186160,
            0.066839, 0.201109, -0.358931, 0.027357, 0.200604, 0.241504, -0.098003, 0.257019, 0.215434, 0.212513
        );
        return weights[input_idx];
    } else if (class_idx == 7) {
        let weights = array<f32, 80>(
            0.117300, 0.032408, -0.005667, 0.107268, 0.006546, -0.031538, -0.029169, 0.077424, 0.044628, 0.103978,
            -0.016931, -0.064625, -0.112280, -0.054283, 0.017954, 0.051360, -0.380526, -0.228865, -0.320902, -0.218059,
            -0.322153, -0.148147, -0.200158, -0.219849, -0.339847, -0.172780, -0.188492, -0.220040, -0.675989, -0.416856,
            -0.303892, -0.287565, -0.228723, -0.158366, -0.217259, -0.094817, 0.014257, 0.063357, -0.035585, -0.070369,
            -0.012991, 0.080604, -0.075443, -0.034477, -0.174091, -0.035405, -0.028821, 0.051290, 0.450173, 0.305964,
            0.216981, 0.254185, 0.139813, 0.144985, 0.081886, 0.156681, 0.081503, 0.086727, 0.042168, 0.182680,
            0.057246, -0.003732, -0.035798, -0.089016, 0.391240, 0.250796, 0.141621, 0.058678, 0.250263, 0.084234,
            -0.031731, -0.052589, 0.112463, -0.177604, -0.345726, -0.315893, -0.258114, -0.393978, -0.516443, -0.500820
        );
        return weights[input_idx];
    } else if (class_idx == 8) {
        let weights = array<f32, 80>(
            -0.240393, -0.185176, -0.149626, -0.110310, 0.015833, 0.001879, -0.051396, -0.095766, -0.018788, -0.133992,
            -0.135422, -0.228117, 0.197478, 0.081719, 0.025546, -0.335021, 0.207124, 0.164186, 0.205313, 0.205886,
            0.103280, 0.098387, 0.103350, 0.136596, 0.095375, 0.090829, 0.079595, 0.160674, 0.119854, 0.189499,
            0.189202, 0.315189, 0.003699, -0.069336, -0.030007, -0.102130, -0.017694, -0.045719, -0.011990, -0.013453,
            0.032844, -0.003869, 0.074134, -0.015000, -0.092588, -0.031691, 0.031374, 0.130070, -0.093359, -0.007090,
            0.026482, 0.003300, 0.167083, 0.013804, 0.019061, -0.057163, 0.011991, -0.099968, -0.004993, -0.112764,
            0.186200, 0.034468, 0.083321, -0.052002, -0.109627, -0.075757, -0.040020, -0.008206, -0.267105, -0.078971,
            -0.056242, -0.005564, -0.388854, -0.093096, -0.054447, -0.067253, -0.162213, 0.085767, 0.066933, 0.116155
        );
        return weights[input_idx];
    } else if (class_idx == 9) {
        let weights = array<f32, 80>(
            -0.036853, -0.082459, -0.122891, -0.106259, 0.032625, 0.034822, -0.001182, -0.037191, -0.015643, 0.042807,
            -0.009214, 0.045717, -0.157412, -0.139232, -0.208329, -0.046141, 0.228707, 0.109149, 0.139504, 0.061754,
            0.123818, 0.040161, 0.049808, -0.042714, 0.064777, 0.053334, 0.011123, -0.114467, -0.224084, -0.222565,
            -0.286206, -0.322185, -0.058826, -0.069894, -0.046423, -0.124963, -0.157684, -0.071409, 0.011164, 0.109790,
            0.016827, -0.007568, 0.005793, 0.082027, -0.170847, 0.086154, 0.071517, 0.092638, 0.034005, 0.088124,
            0.086706, 0.140357, -0.005547, 0.063606, 0.024153, 0.174176, 0.047137, 0.063903, 0.065014, 0.128223,
            0.083249, 0.064771, 0.096603, 0.092134, -0.077306, 0.084782, 0.061068, 0.046091, -0.192227, -0.003513,
            -0.091003, -0.161677, -0.106110, -0.027746, -0.217130, -0.391716, -0.334998, -0.255896, -0.390191, -0.428108
        );
        return weights[input_idx];
    }
    return 0.0;
}

fn get_fc_bias(class_idx: i32) -> f32 {
    let biases = array<f32, 10>(-2.159656, 0.558099, -0.764123, -1.360882, 0.812445, 1.631978, -0.752901, 1.732814, 0.019281, 0.478689);
    return biases[class_idx];
}

fn relu(x: f32) -> f32 {
    return max(0.0, x);
}

fn normalize_input(value: f32) -> f32 {
    return (value - params.normalization_mean) / params.normalization_std;
}

fn render_digit(pos: vec2<f32>, char_pos: vec2<f32>, digit: u32, size: f32) -> f32 {
    return ch(pos, char_pos, digit + CHAR_0, size);
}


fn canvas_index(x: i32, y: i32) -> u32 {
    return u32(y * i32(INPUT_SIZE) + x);
}

fn conv1_index(x: i32, y: i32, fmap: i32) -> u32 {
    return u32(fmap * i32(CONV1_SIZE * CONV1_SIZE) + y * i32(CONV1_SIZE) + x);
}

fn conv2_index(x: i32, y: i32, fmap: i32) -> u32 {
    return u32(fmap * i32(CONV2_SIZE * CONV2_SIZE) + y * i32(CONV2_SIZE) + x);
}

fn screen_to_canvas(p: vec2<f32>, res: vec2<f32>) -> vec2<i32> {
    let q = vec2(p.x, 1.-p.y);
    let start = vec2(params.canvas_offset_x, params.canvas_offset_y);
    let end = start + params.canvas_size;
    if any(q < start) || any(q > end) { return vec2(-1); }
    let rel = (q - start) / params.canvas_size * params.input_resolution;
    return min(vec2<i32>(rel), vec2(i32(params.input_resolution - 1.)));
}


fn sample_canvas(pos: vec2<i32>) -> f32 {
    if (pos.x < 0 || pos.x >= i32(INPUT_SIZE) || pos.y < 0 || pos.y >= i32(INPUT_SIZE)) {
        return 0.0;
    }
    return canvas_data[canvas_index(pos.x, pos.y)];
}

fn sample_conv1(pos: vec2<i32>, fmap: i32) -> f32 {
    if (pos.x < 0 || pos.x >= i32(CONV1_SIZE) || pos.y < 0 || pos.y >= i32(CONV1_SIZE) || fmap < 0 || fmap >= i32(FEATURE_MAPS_1)) {
        return 0.0;
    }
    return conv1_data[conv1_index(pos.x, pos.y, fmap)];
}

@compute @workgroup_size(1, 1, 1)
fn canvas_update(@builtin(global_invocation_id) id: vec3<u32>) {
    let pos = vec2<i32>(id.xy);
    if any(pos >= vec2(i32(INPUT_SIZE))) { return; }
    
    let idx = canvas_index(pos.x, pos.y);
    let btns = mouse.buttons.x;
    
    if params.clear_canvas == 1 || (btns & 2u) != 0u {
        canvas_data[idx] = 0.;
        return;
    }
    
    if (btns & 1u) != 0u {
        let mouse_pos = mouse.position;
        let canvas_pos = screen_to_canvas(mouse_pos, vec2<f32>(textureDimensions(output)));
        if canvas_pos.x >= 0 {
            let dist = length(vec2<f32>(canvas_pos - pos));
            let radius = params.brush_size * params.input_resolution * 10.;
            let intensity = 1. - smoothstep(0., radius, dist);
            if intensity > 0. {
                canvas_data[idx] = min(1., canvas_data[idx] + intensity * 0.3); // Normal brush intensity
            }
        }
    }
}

@compute @workgroup_size(1, 1, 1)
fn conv_layer1(@builtin(global_invocation_id) id: vec3<u32>) {
    let pos = vec3<i32>(id);
    if any(pos.xy >= vec2(i32(CONV1_SIZE))) || pos.z >= i32(FEATURE_MAPS_1) { return; }
    
    let pool_xy = pos.xy * 2;
    var max_val = -1000.;
    
    for (var d = 0; d < 4; d++) {
        let conv_xy = pool_xy + vec2(d & 1, d >> 1);
        var sum = get_conv1_bias(pos.z);
        
        for (var k = 0; k < 25; k++) {
            let kxy = vec2(k % 5, k / 5);
            let input_xy = conv_xy + kxy;
            
            let flipped_y = i32(INPUT_SIZE) - 1 - input_xy.y;
            let flipped_xy = vec2(input_xy.x, flipped_y);
            
            let input_val = normalize_input(sample_canvas(flipped_xy));
            sum += input_val * get_conv1_weight(pos.z, k);
        }
        
        max_val = max(max_val, max(0., sum));
    }
    
    conv1_data[conv1_index(pos.x, pos.y, pos.z)] = max_val;
}

@compute @workgroup_size(1, 1, 1)
fn conv_layer2(@builtin(global_invocation_id) id: vec3<u32>) {
    let pos = vec3<i32>(id);
    if any(pos.xy >= vec2(i32(CONV2_SIZE))) || pos.z >= i32(FEATURE_MAPS_2) { return; }
    
    let pool_xy = pos.xy * 2;
    var max_val = -1000.;
    
    for (var d = 0; d < 4; d++) {
        let conv_xy = pool_xy + vec2(d & 1, d >> 1);
        var sum = get_conv2_bias(pos.z);
        
        for (var fm = 0; fm < i32(FEATURE_MAPS_1); fm++) {
            for (var k = 0; k < 25; k++) {
                let kxy = vec2(k % 5, k / 5);
                let input_xy = conv_xy + kxy;
                let input_val = sample_conv1(input_xy, fm);
                sum += input_val * get_conv2_weight(pos.z, fm, k);
            }
        }
        
        max_val = max(max_val, max(0., sum));
    }
    
    conv2_data[conv2_index(pos.x, pos.y, pos.z)] = max_val;
}

@compute @workgroup_size(1, 1, 1)
fn fully_connected(@builtin(global_invocation_id) id: vec3<u32>) {
    let class_idx = i32(id.x);
    if class_idx >= i32(NUM_CLASSES) { return; }
    
    var sum = get_fc_bias(class_idx);
    let conv2_size_sq = i32(CONV2_SIZE * CONV2_SIZE);
    
    for (var i = 0; i < i32(FEATURE_MAPS_2) * conv2_size_sq; i++) {
        let fmap = i / conv2_size_sq;
        let xy_idx = i % conv2_size_sq;
        let xy = vec2(xy_idx % i32(CONV2_SIZE), xy_idx / i32(CONV2_SIZE));
        let val = conv2_data[conv2_index(xy.x, xy.y, fmap)];
        sum += val * get_fc_weight(class_idx, i);
    }
    
    fc_data[class_idx] = sum;
}

@compute @workgroup_size(16, 16, 1)
fn main_image(@builtin(global_invocation_id) id: vec3<u32>) {
    let res = textureDimensions(output);
    if any(id.xy >= res) { return; }
    
    let uv = vec2<f32>(f32(id.x), f32(res.y - id.y)) / vec2<f32>(res);
    var color = vec3(.02, .02, .05);
    
    let canvas_start = vec2(params.canvas_offset_x, params.canvas_offset_y);
    let canvas_end = canvas_start + params.canvas_size;
    
    if all(uv >= canvas_start) && all(uv <= canvas_end) {
        color = vec3(0.0); // Black canvas
        
        let canvas_uv = (uv - canvas_start) / params.canvas_size;
        let canvas_coord = vec2<i32>(canvas_uv * params.input_resolution);
        
        if all(canvas_coord >= vec2(0)) && all(canvas_coord < vec2(i32(params.input_resolution))) {
            let val = sample_canvas(canvas_coord);
            color = mix(color, vec3(1.0), val); // White for drawn pixels
        }
        
        let border = .005;
        if any(uv < canvas_start + border) || any(uv > canvas_end - border) {
            color = vec3(.5);
        }
    }
    
    var predictions: array<f32, 10>;
    var max_logit = -1000.;
    
    for (var i = 0; i < i32(NUM_CLASSES); i++) {
        predictions[i] = fc_data[i];
        max_logit = max(max_logit, predictions[i]);
    }
    
    var exp_sum = 0.;
    for (var i = 0; i < i32(NUM_CLASSES); i++) {
        let exp_val = exp(predictions[i] - max_logit);
        predictions[i] = exp_val;
        exp_sum += exp_val;
    }
    
    let inv_sum = 1. / max(exp_sum, .001);
    for (var i = 0; i < i32(NUM_CLASSES); i++) {
        predictions[i] *= inv_sum;
    }
    
    let bar_start = vec2(.1, .75);
    let bar_dims = vec2(.06, .15);
    let bar_spacing = .08;
    
    if uv.y >= bar_start.y && uv.y <= bar_start.y + bar_dims.y {
        for (var digit = 0; digit < i32(NUM_CLASSES); digit++) {
            let bar_x = bar_start.x + f32(digit) * bar_spacing;
            
            if uv.x >= bar_x && uv.x <= bar_x + bar_dims.x {
                let confidence = predictions[digit];
                let bar_uv = (uv - vec2(bar_x, bar_start.y)) / bar_dims;
                
                color = vec3(.2);
                
                if bar_uv.y <= confidence {
                    color = mix(vec3(0., .5, 1.), vec3(1., .5, 0.), confidence) * (confidence * 3.);
                }
                
                var max_conf = 0.;
                var max_digit = 0;
                for (var i = 0; i < i32(NUM_CLASSES); i++) {
                    if predictions[i] > max_conf {
                        max_conf = predictions[i];
                        max_digit = i;
                    }
                }
                
                if digit == max_digit && max_conf > params.prediction_threshold {
                    let glow = sin(time_data.time * 3.) * .2 + .8;
                    color = mix(color, vec3(1., 1., 0.), .3 * glow);
                }
                
            }
        }
    }
    let pixel_pos = vec2<f32>(f32(id.x), f32(id.y));
    let label_y = 0.05;
    
    for (var digit = 0; digit < i32(NUM_CLASSES); digit++) {
        let bar_x = bar_start.x + f32(digit) * bar_spacing;
        let digit_screen_pos = vec2<f32>(
            bar_x * f32(res.x) + bar_dims.x * f32(res.x) * 0.5 - 16.0,
            label_y * f32(res.y)
        );
        let digit_alpha = render_digit(pixel_pos, digit_screen_pos, u32(digit), 32.0);
        color = mix(color, vec3(1.0), digit_alpha);
    }
    let mouse_corrected = vec2<f32>(mouse.position.x, 1.0 - mouse.position.y);
    let mouse_dist = distance(uv, mouse_corrected);
    if mouse_dist < .02 {
        let pulse = sin(time_data.time * 10.) * .5 + .5;
        color = mix(color, vec3(1.), .3 * pulse);
    }
    
    textureStore(output, vec2<i32>(id.xy), vec4(pow(color, vec3(.8)), 1.));
}